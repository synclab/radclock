From 60244d7518c0e8cd30b014ebea4af05744c5dc43 Mon Sep 17 00:00:00 2001
From: Julien Ridoux <julien@synclab.org>
Date: Thu, 28 May 2009 14:01:33 +1000
Subject: [PATCH RADclock 7/9] RADclock packets timestamps

Create raw vcounter and fair timeval timestamps on incoming and outgoing
packets captured.
---
 net/core/dev.c |   64 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 64 insertions(+), 0 deletions(-)

diff --git a/net/core/dev.c b/net/core/dev.c
index 5a25896..6d2e85d 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -127,6 +127,9 @@
 #include <linux/in.h>
 #include <linux/jhash.h>
 #include <linux/random.h>
+#ifdef CONFIG_RADCLOCK
+#include <linux/clocksource.h>
+#endif
 
 #include "net-sysfs.h"
 
@@ -1302,8 +1305,28 @@ static void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct packet_type *ptype;
 
+#ifdef CONFIG_RADCLOCK
+	ktime_t tv_fair;
+	vcounter_t vcount;
+#endif
+
 	net_timestamp(skb);
 
+#ifdef CONFIG_RADCLOCK
+	/* At this point, we have no way of knowing if we tap the packets
+	 * in RADCLOCK_TSMODE_FAIRCOMPARE mode or not. So we take another
+	 * timestamp we ensure to be 'fair'.
+	 */
+	rdtsc_barrier(); /* Make sure GCC doesn't mess up the compare */
+	tv_fair = ktime_get_real();
+	vcount = read_vcounter();
+	rdtsc_barrier(); /* Make sure GCC doesn't mess up the compare */
+
+	/* Copy the two specific RADclock timestamps to the skbuff */
+	skb->vcount_stamp = vcount;
+	skb->tstamp_fair = tv_fair;
+#endif
+
 	rcu_read_lock();
 	list_for_each_entry_rcu(ptype, &ptype_all, list) {
 		/* Never send packets back to the socket
@@ -1900,10 +1923,31 @@ int netif_rx(struct sk_buff *skb)
 	struct softnet_data *queue;
 	unsigned long flags;
 
+	#ifdef CONFIG_RADCLOCK
+	/* At this point, we have no way of knowing if we tap the packets
+	 * in RADCLOCK_TSMODE_FAIRCOMPARE mode or not. So we take another
+	 * timestamp we ensure to be 'fair'.
+	 */
+	ktime_t tv_fair;
+	vcounter_t vcount;
+
+	rdtsc_barrier(); /* Make sure GCC doesn't mess up the compare */
+	vcount = read_vcounter();
+	tv_fair = ktime_get_real();
+	rdtsc_barrier(); /* Make sure GCC doesn't mess up the compare */
+	#endif
+
 	/* if netpoll wants it, pretend we never saw it */
 	if (netpoll_rx(skb))
 		return NET_RX_DROP;
 
+	#ifdef CONFIG_RADCLOCK
+	/* Copy the two specific RADclock timestamps to the skbuff */
+	skb->vcount_stamp = vcount;
+	skb->tstamp_fair  = tv_fair;
+	#endif
+
+
 	if (!skb->tstamp.tv64)
 		net_timestamp(skb);
 
@@ -2187,10 +2231,30 @@ int netif_receive_skb(struct sk_buff *skb)
 	int ret = NET_RX_DROP;
 	__be16 type;
 
+	#ifdef CONFIG_RADCLOCK
+	/* At this point, we have no way of knowing if we tap the packets
+	 * in RADCLOCK_TSMODE_FAIRCOMPARE mode or not. So we take another
+	 * timestamp we ensure to be 'fair'.
+	 */
+	ktime_t tv_fair;
+	vcounter_t vcount;
+
+	rdtsc_barrier(); /* Make sure GCC doesn't mess up the compare */
+	vcount = read_vcounter();
+	tv_fair = ktime_get_real();
+	rdtsc_barrier(); /* Make sure GCC doesn't mess up the compare */
+	#endif
+
 	/* if we've gotten here through NAPI, check netpoll */
 	if (netpoll_receive_skb(skb))
 		return NET_RX_DROP;
 
+	#ifdef CONFIG_RADCLOCK
+	/* Copy the two specific RADclock timestamps to the skbuff */
+	skb->vcount_stamp = vcount;
+	skb->tstamp_fair = tv_fair;
+	#endif
+
 	if (!skb->tstamp.tv64)
 		net_timestamp(skb);
 
-- 
1.5.6.3

